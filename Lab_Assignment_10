#include <bits/stdc++.h>
using namespace std;

// ============================
// QUESTION 1
// Contains duplicate
// ============================

bool containsDuplicate(vector<int> &nums) {
    unordered_set<int> st;
    for (int x: nums) {
        if (st.count(x)) return true;
        st.insert(x);
    }
    return false;
}

// ============================
// QUESTION 2
// Common elements in two arrays
// ============================

vector<int> intersectionArr(vector<int> &A, vector<int> &B) {
    unordered_set<int> s(A.begin(), A.end());
    vector<int> res;
    for (int x: B)
        if (s.count(x)) { res.push_back(x); s.erase(x); }
    return res;
}

// ============================
// QUESTION 3
// Frequency of each number
// ============================

void freqCount(vector<int> &nums) {
    unordered_map<int,int> mp;
    for (int x: nums) mp[x]++;
    for (auto &p: mp) {
        cout << p.first << " -> " << p.second << " times\n";
    }
}

// ============================
// QUESTION 4
// First non-repeating element
// ============================

int firstNonRepeating(vector<int> &nums) {
    unordered_map<int,int> mp;
    for (int x: nums) mp[x]++;
    for (int x: nums)
        if (mp[x]==1) return x;
    return -1;
}

// ============================
// QUESTION 5
// Detect loop in linked list using hash set
// ============================

struct Node {
    int data;
    Node* next;
    Node(int x): data(x), next(NULL) {}
};

bool hasCycle(Node* head) {
    unordered_set<Node*> st;
    Node* cur=head;
    while (cur) {
        if (st.count(cur)) return true;
        st.insert(cur);
        cur = cur->next;
    }
    return false;
}

// ============================
// QUESTION 6
// Duplicates in binary tree (values)
// ============================

struct TreeNode {
    int val;
    TreeNode *left,*right;
    TreeNode(int v):val(v),left(NULL),right(NULL){}
};

bool checkDup(TreeNode* root, unordered_set<int> &seen) {
    if (!root) return false;
    if (seen.count(root->val)) return true;
    seen.insert(root->val);
    return checkDup(root->left,seen) || checkDup(root->right,seen);
}

bool hasDuplicate(TreeNode* root) {
    unordered_set<int> seen;
    return checkDup(root,seen);
}

// ============================
// Additional example:
// Most frequent element (tie -> largest value)
// ============================

int mostFrequentLargest(vector<int> &arr) {
    unordered_map<int,int> mp;
    for (int x: arr) mp[x]++;
    int bestVal = INT_MIN, bestFreq = 0;
    for (auto &p: mp) {
        int val=p.first, f=p.second;
        if (f > bestFreq || (f==bestFreq && val > bestVal)) {
            bestFreq = f;
            bestVal = val;
        }
    }
    return bestVal;
}

int main() {
    return 0;
}
