#include <bits/stdc++.h>
using namespace std;

// ============================
// Using adjacency list
// ============================

// ============================
// QUESTION 1
// BFS
// ============================

void BFS(int n, vector<vector<int>> &adj, int src) {
    vector<int> vis(n,0);
    queue<int> q;
    vis[src]=1; q.push(src);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        cout << u << " ";
        for (int v : adj[u]) {
            if (!vis[v]) {
                vis[v]=1;
                q.push(v);
            }
        }
    }
}

// ============================
// QUESTION 2
// DFS
// ============================

void dfsUtil(int u, vector<vector<int>> &adj, vector<int> &vis) {
    vis[u]=1;
    cout << u << " ";
    for (int v : adj[u])
        if (!vis[v]) dfsUtil(v,adj,vis);
}

void DFS(int n, vector<vector<int>> &adj, int src) {
    vector<int> vis(n,0);
    dfsUtil(src,adj,vis);
}

// ============================
// QUESTION 3
// MST using Kruskal and Prim
// ============================

struct Edge {
    int u,v,w;
};

struct DSU {
    vector<int> parent, rankv;
    DSU(int n):parent(n),rankv(n,0){
        iota(parent.begin(), parent.end(),0);
    }
    int find(int x){ return parent[x]==x?x:parent[x]=find(parent[x]); }
    bool unite(int x,int y){
        x=find(x); y=find(y);
        if (x==y) return false;
        if (rankv[x]<rankv[y]) swap(x,y);
        parent[y]=x;
        if (rankv[x]==rankv[y]) rankv[x]++;
        return true;
    }
};

int kruskalMST(int n, vector<Edge> &edges) {
    sort(edges.begin(),edges.end(),[](auto &a, auto &b){return a.w<b.w;});
    DSU d(n);
    int cost=0, cnt=0;
    for (auto &e:edges) {
        if (d.unite(e.u,e.v)) {
            cost += e.w;
            cnt++;
            if (cnt==n-1) break;
        }
    }
    return cost;
}

int primMST(int n, vector<vector<pair<int,int>>> &adj) {
    vector<int> key(n, INT_MAX), inMST(n,0);
    key[0]=0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0,0});
    int cost=0;
    while (!pq.empty()) {
        auto [w,u] = pq.top(); pq.pop();
        if (inMST[u]) continue;
        inMST[u]=1; cost += w;
        for (auto &p:adj[u]) {
            int v=p.first, wt=p.second;
            if (!inMST[v] && wt<key[v]) {
                key[v]=wt;
                pq.push({wt,v});
            }
        }
    }
    return cost;
}

// ============================
// QUESTION 4
// Dijkstra shortest path
// ============================

vector<int> dijkstra(int n, vector<vector<pair<int,int>>> &adj, int src) {
    const int INF = 1e9;
    vector<int> dist(n, INF);
    dist[src]=0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0,src});
    while (!pq.empty()) {
        auto [d,u]=pq.top(); pq.pop();
        if (d>dist[u]) continue;
        for (auto &p: adj[u]) {
            int v=p.first, w=p.second;
            if (dist[u]+w<dist[v]) {
                dist[v]=dist[u]+w;
                pq.push({dist[v],v});
            }
        }
    }
    return dist;
}

int main() {
    return 0;
}
